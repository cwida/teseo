/**
 * Copyright (C) 2019 Dean De Leo, email: dleo[at]cwi.nl
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#pragma once

#include <chrono>
#include <cinttypes>
#include <limits>
#include <string>

namespace teseo::context {

/**
 * Configuration parameters that need to be set at compile time
 */
struct StaticConfiguration {
    /**
     * The minimum delay between when request to rebalance is issued by a writer and
     * when it is handled by an asynchronous rebalancer
     */
    constexpr static std::chrono::milliseconds async_delay { 200 }; // ms

    /**
     * Number of background threads performing rebalances on the background
     */
    constexpr static uint64_t async_num_threads = @conf_async_num_threads@;
    
    /**
     * Whether to cache the last computed auxiliary view, so that it can be reused
     * among multiple transactions.
     */
    constexpr static bool aux_cache_enabled = true;
    
    /**
     * Use the auxiliary view to answer the degree of a vertex
     * This setting can be also enabled or disable at runtime using:
     * - context::global_context()->enable_aux_degree();
     * - context::global_context()->disable_aux_degree();  
     */
    constexpr static bool aux_degree_enabled = true;
    
    /**
     * Automatically build the aux view after the user requested the degree for Nth time.
     */
    constexpr static uint64_t aux_degree_threshold = 10;
    
    /**
     * Set the multiplier for the hash dictionary used to translate the vertex IDs into
     * logical IDs in the static views. The multiplier `m' defines the ultimate capacity
     * of the hash table and is the reciprocal of the load factor (1/m).
     */
    constexpr static uint64_t aux_hash_multiplier = 4;
    static_assert(aux_hash_multiplier > 1);
     
    /**
     * The initial capacity of the containers, in terms of number of vertices, used in the 
     * intermediates to create the aux view. The capacity can still be further increased 
     * eventually upon necessity.
     */ 
    constexpr static uint64_t aux_partial_init_capacity = 4096;
    
    /**
     * Amount of _logical_ memory, in bytes, reserved for use in the buffer pool. The value 0 will 
     * automatically determine a proper limit at runtime.
     */
    constexpr static uint64_t bp_max_logical_memory = @conf_bp_max_logical_memory@;
    static_assert(bp_max_logical_memory % (1ull<<21) == 0, "Expected to be a multiple of 2MB");
    
    /**
     * The amount of pages allocated at startup. The actual number of pages can be eventually 
     * expanded at runtime
     */
    constexpr static uint64_t bp_min_num_pages = @conf_bp_min_num_pages@;
    
    /**
     * The size of each physical page, in bytes, allocated in the buffer pool.
     */
    constexpr static uint64_t bp_page_size = @conf_bp_page_size@;
    
    /**
     * The capacity of the thread contexts list upon creation (it can be further expanded at runtime)
     */
    constexpr static uint64_t context_tclist_initial_capacity = @conf_tclist_initial_capacity@;

    /**
     * The height of the calibrator tree [0 => log2(num_segments)]
     */
    constexpr static uint64_t crawler_calibrator_tree_height = @conf_crawler_calibrator_tree_height@;
    
    /**
     * The initial capacity of a queue in the GC, in terms of number of entries
     */ 
    constexpr static uint64_t gc_queue_initial_capacity = 1024;
    
    /**
     * Whether to allocate the leaves of the memstore on huge pages
     */
    constexpr static bool huge_pages = @conf_huge_pages@;

    /**
     * The number of segments in each leaf of the memstore
     */
    constexpr static uint64_t memstore_num_segments_per_leaf = @conf_memstore_num_segments_per_leaf@;

    /**
     * The size of each segment, as multiple of sizeof(uint64_t)
     */
    constexpr static uint64_t memstore_segment_size = @conf_memstore_segment_size@;

    /**
     * How often to run the merger service
     */
    constexpr static std::chrono::milliseconds merger_frequency { 1000 * 20 }; // 20 secs
    
    /**
     * How often to check whether physical memory can be released from the buffer pool 
     */
    constexpr static std::chrono::milliseconds runtime_bp_frequency { 1000 }; // 1 sec 
    
    /**
     * The minimum delay between when request to rebalance is issued by a writer and
     * when it is handled by an asynchronous rebalancer
     */
    constexpr static std::chrono::milliseconds runtime_delay_rebalance { 200 }; // ms
    
    /**
     * How often to execute the garbage collector
     */
    constexpr static std::chrono::milliseconds runtime_gc_frequency { 20 }; // ms
    
    /**
     * Number of background threads performing the maintenance tasks. The value 0 will
     * automatically set a default number of threads at runtime, depending on the underlying 
     * machine.
     */
    constexpr static uint64_t runtime_num_threads = @conf_runtime_num_threads@;
    
    /**
     * How often to refresh a cached transaction list
     */
    constexpr static std::chrono::milliseconds runtime_txnlist_refresh { @conf_runtime_txnlist_refresh@ }; // ms
    
    /**
     * Frequency to rebuild the free list in the cached transaction pools 
     */
    constexpr static std::chrono::milliseconds runtime_txnpool_frequency { 300 }; // ms
    
    /**
     * Whether the configuration has been generated in `test mode'
     */
    constexpr static bool test_mode = @test_mode@;

    /**
     * The fill factor, in [0, 1], on when a memory pool can be reused by another thread
     */
    constexpr static double transaction_memory_pool_ffreuse = 0.1;

    /**
     * Max number of memory pools that can be cached, ready to be reused
     */
    constexpr static uint64_t transaction_memory_pool_list_cache_size = 8;

    /**
     * The capacity of each memory pool, in terms of number of transactions.
     */
    constexpr static uint32_t transaction_memory_pool_size = @conf_transaction_memory_pool_size@;

    /**
     * The default size, in bytes, of an undo buffer created by a transaction
     */
    constexpr static uint32_t transaction_undo_buffer_size = 4096;

    /**
     * The size, in bytes, of the first undo stored inside a transaction. When a transaction
     * is created, we always embed a small undo buffer with it of the following size:
     */
    constexpr static uint32_t transaction_undo_embedded_size = 128; // space for 2 updates
};

} // namespace
