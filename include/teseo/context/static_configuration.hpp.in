/**
 * Copyright (C) 2019 Dean De Leo, email: dleo[at]cwi.nl
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#pragma once

#include <chrono>
#include <cinttypes>
#include <limits>
#include <string>

namespace teseo::context {

/**
 * Configuration parameters that need to be set at compile time
 */
struct StaticConfiguration {
    /**
     * The minimum delay between when request to rebalance is issued by a writer and
     * when it is handled by an asynchronous rebalancer
     */
    constexpr static std::chrono::milliseconds async_delay { 200 }; // ms

    /**
     * Number of background threads performing rebalances on the background
     */
    constexpr static uint64_t async_num_threads = @conf_async_num_threads@;
    
    /**
     * The capacity of the thread contexts list upon creation (it can be further expanded at runtime)
     */
    constexpr static uint64_t context_tclist_initial_capacity = @conf_tclist_initial_capacity@;

    /**
     * The height of the calibrator tree [0 => log2(num_segments)]
     */
    constexpr static uint64_t crawler_calibrator_tree_height = @conf_crawler_calibrator_tree_height@;
    
    /**
     * The initial capacity of a queue in the GC, in terms of number of entries
     */ 
    constexpr static uint64_t gc_queue_initial_capacity = 1024;

    /**
     * The number of segments in each leaf of the memstore
     */
    constexpr static uint64_t memstore_num_segments_per_leaf = @conf_memstore_num_segments_per_leaf@;

    /**
     * The size of each segment, as multiple of sizeof(uint64_t)
     */
    constexpr static uint64_t memstore_segment_size = @conf_memstore_segment_size@;

    /**
     * How often to run the merger service
     */
    constexpr static std::chrono::milliseconds merger_frequency { 1000 * 30 }; // 30 secs
    
    /**
     * The minimum delay between when request to rebalance is issued by a writer and
     * when it is handled by an asynchronous rebalancer
     */
    constexpr static std::chrono::milliseconds runtime_delay_rebalance { 200 }; // ms
    
    /**
     * How often to execute the garbage collector
     */
    constexpr static std::chrono::milliseconds runtime_gc_frequency { 20 }; // ms
    
    /**
     * Number of background threads performing the maintenance tasks. The value 0 will
     * automatically set a default number of threads at runtime, depending on the underlying 
     * machine.
     */
    constexpr static uint64_t runtime_num_threads = @conf_runtime_num_threads@;
    
    /**
     * How often to refresh a cached transaction list
     */
    constexpr static std::chrono::milliseconds runtime_txnlist_refresh { @conf_runtime_txnlist_refresh@ }; // ms
    
    /**
     * Frequency to rebuild the free list in the cached transaction pools 
     */
    constexpr static std::chrono::milliseconds runtime_txnpool_frequency { 300 }; // ms
    
    /**
     * Whether the configuration has been generated in `test mode'
     */
    constexpr static bool test_mode = @test_mode@;

    /**
     * The fill factor, in [0, 1], on when a memory pool can be reused by another thread
     */
    constexpr static double transaction_memory_pool_ffreuse = 0.1;

    /**
     * Max number of memory pools that can be cached, ready to be reused
     */
    constexpr static uint64_t transaction_memory_pool_list_cache_size = 8;

    /**
     * The capacity of each memory pool, in terms of number of transactions.
     */
    constexpr static uint32_t transaction_memory_pool_size = @conf_transaction_memory_pool_size@;

    /**
     * The default size, in bytes, of an undo buffer created by a transaction
     */
    constexpr static uint32_t transaction_undo_buffer_size = 4096;

    /**
     * The size, in bytes, of the first undo stored inside a transaction. When a transaction
     * is created, we always embed a small undo buffer with it of the following size:
     */
    constexpr static uint32_t transaction_undo_embedded_size = 128; // space for 2 updates
};

} // namespace
